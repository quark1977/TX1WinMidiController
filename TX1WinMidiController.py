"""
MIT License

Copyright (c) 2024 quark77

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

# This script includes code suggestions generated by ChatGPT, OpenAI (https://openai.com/chatgpt).
# Implements a simple Windows GUI for selecting TonexOne presets from the GUI or via Midi control (Program Change 1-20). 
# Calls on tonex.py for USB-communication with TonexOne, in particular to initially read preset names for buttons and then to switch presets.
# Lookup of skin name of a specific preset in library.db, to call upon the respective skin picture in /assets (e.g. JTM.png, suggest pic width of 1000px)

import os
import threading
import time
import mido
import re
import sys
import sqlite3
import tkinter as tk
from tkinter import PhotoImage
from config import Config # Import from config.json
from tonex import Presetsend  # Importing the Presetsend function
from tonex import Initlist
from tonex import Activepreset

# Pupulate Global variables from config.json
config = Config()
app_name = config.get("general", "app_name", "TX1 Win Midi Controller")
version = config.get("general", "version", "1.0")
db_path = config.get("paths", "db_path", "library.db")
skin_path = config.get("paths", "skin_path", "assets/")
window_title = config.get("interface", "window_title", "TX1 Win Midi Controller")
geometry = config.get("interface", "geometry", "1920x1080")
window_state = config.get("interface", "window_state", "normal")
fullscreen = config.get("interface", "fullscreen", 0)
width = config.getint("interface", "width", 800)
height = config.getint("interface", "height", 600)
background_color = config.get("interface", "background_color", "#1E1E1E") # very dark grey
button_color = config.get("interface", "button_color", "#BFBFBF") # light grey
button_markupcolor = config.get("interface", "button_markupcolor", "light green")
button_fontsize = config.getint("interface", "button_fontsize", 16)
button_font = config.get("interface", "button_font", "Arial")
button_fontcolor = config.get("interface", "button_fontcolor", "black")
preset_fontsize = config.getint("interface", "preset_fontsize", 32)
preset_font = config.get("interface", "preset_font", "Arial")
preset_fontcolor = config.get("interface", "preset_fontcolor", "white")
preset_wrap_length = config.get("interface", "preset_wrap_length", 500)
image_max_width = config.get("interface", "image_max_width", 700)
image_max_height = config.get("interface", "image_max_height", 500)
midi_channel = config.get("midi", "midi_channel", "all") # all, 1, 2...
    
preset_names = []  # To store preset names later
active_button = None

# Main application window
root = tk.Tk()
root.title(window_title)
root.geometry(geometry)  # Start in HD resolution
root.minsize(width, height)  # Minimum window size
root.configure(bg=background_color)  # Set background color to black
root.state(window_state) # Maximize the window
if fullscreen: root.attributes("-fullscreen", True)

# Create a status bar at the bottom
class RedirectedStdout:
    """Redirects stdout to a tkinter widget."""
    def __init__(self, widget, buffer_size=1):
        self.widget = widget
        self.buffer_size = buffer_size  # Number of messages to retain
        self.messages = []             # To keep track of the message queue

    def write(self, message):
        # Add the new message to the queue
        if message.strip():  # Avoid adding empty messages
            self.messages.append(message.strip())
            if len(self.messages) > self.buffer_size:
                self.messages.pop(0)  # Remove oldest message if over buffer size

            # Update the status bar text
            self.widget.config(text=" | ".join(self.messages))
            self.widget.update_idletasks()  # Force immediate refresh       

    def flush(self):
        pass  # For compatibility with stdout
    
    def clear(self):
        """Clears the status bar."""
        self.messages = []  # Empty the message queue
        self.widget.config(text="")  # Clear the text in the status bar
        self.widget.update_idletasks()  # Force immediate refresh
        self.cleared = True  # Set the cleared flag

# Create a status bar at the bottom
status_frame = tk.Frame(root, bd=1, relief=tk.SUNKEN)
status_frame.pack(side=tk.BOTTOM, fill=tk.X)
status_frame.config(bg=background_color, bd=0)
status_frame.update_idletasks() 

# Left-aligned status message
status_bar = tk.Label(status_frame, text="Ready", anchor=tk.W)
status_bar.pack(side=tk.LEFT, fill=tk.X, expand=True)
status_bar.config(bg=background_color, fg=preset_fontcolor, bd=0)
status_bar.update_idletasks() 
redirected_stdout = RedirectedStdout(status_bar, buffer_size=3)
sys.stdout = redirected_stdout #redirect all print to status bar
#sys.stderr = redirected_stdout #redirect all error to status bar
print("Switch to TonexOne stomp mode to use the presets you selected here.")
root.after(5000, redirected_stdout.clear)  # Correctly call the clear method

# Right-aligned message for PC
pc_label = tk.Label(status_frame, text="", anchor=tk.E, padx=10)
pc_label.pack(side=tk.RIGHT)
pc_label.config(bg=background_color, fg=preset_fontcolor, bd=0)
pc_label.update_idletasks() 

def update_pc_message(pc_message):
    pc_label.config(text=pc_message)
    pc_label.update_idletasks()  # Force the update

# Frame for the image and text
left_frame = tk.Frame(root, bg=background_color)
left_frame.pack(side=tk.LEFT, expand=True, fill=tk.BOTH, padx=20, pady=20)

# Display selected model name
model_name = tk.StringVar()
model_name.set("No Preset Selected")
model_label = tk.Label(left_frame, textvariable=model_name, font=(preset_font, preset_fontsize), bg=background_color, fg=preset_fontcolor, wraplength=preset_wrap_length, padx=0, pady=100)
model_label.pack(side=tk.TOP, pady=20)

# Placeholder for the image
image_label = tk.Label(left_frame, bg=background_color)
image_label.pack(side=tk.BOTTOM, expand=True, fill=tk.BOTH, pady=10)


# Function to dynamically update the image
def update_image(skin_result):
    # Updates the displayed image based on the skin result.
    max_width, max_height = image_max_width, image_max_height  # Max dimensions for the image display area
    image_path = os.path.abspath(f"{skin_path}{skin_result}.png")

    if not os.path.exists(image_path):
        image_label.config(image='', text="Image not found", font=(preset_font, 16), fg=preset_fontcolor)
    else:
        try:
            # Load the image
            image = PhotoImage(file=image_path)

            # Get original dimensions
            original_width = image.width()
            original_height = image.height()

            # Calculate scale factor
            scale_factor = min(max_width / original_width, max_height / original_height, 1)
            new_width = int(original_width * scale_factor)
            new_height = int(original_height * scale_factor)

            # Resize using PhotoImage subsampling
            if scale_factor < 1:  # Only subsample if scaling down
                subsample_x = original_width // new_width
                subsample_y = original_height // new_height
                image = image.subsample(subsample_x, subsample_y)

            # Display the image
            image_label.config(image=image, width=max_width, height=max_height)
            image_label.image = image  # Save reference to avoid garbage collection
            image_label.config(text="")  # Clear any error text

            # Set the width of the model label to match the image
            model_label.config(wraplength=max_width)
        except tk.TclError as e:
            print(f"Error loading image {skin_result}.png")
            #print(f"Error loading image: {e}")
            image_label.config(image='', text="Error loading image", font=(preset_font, 16), fg=preset_fontcolor)


# Retrieve Skin name from the library.db database
def get_skin_by_preset_name(db_path, preset_name):
    
    try:
        # Connect to the database
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Step 1: Find the ToneModel_GUID in the Presets table based on the Tag_PresetName
        cursor.execute("""
            SELECT ToneModel_GUID FROM Presets WHERE Tag_PresetName = ?
        """, (preset_name,))
        tone_model_guid = cursor.fetchone()
        
        if not tone_model_guid:
            return None
        
        tone_model_guid = tone_model_guid[0]
        
        # Step 2: Find the Skin field in the ToneModels table based on the GUID
        cursor.execute("""
            SELECT Skin FROM ToneModels WHERE GUID = ?
        """, (tone_model_guid,))
        skin = cursor.fetchone()
        
        if not skin:
            return None
        
        skin = skin[0]
        return skin
    
    except sqlite3.Error as e:
        print(f"SQLite error: {e}")
        return None
    
    finally:
        if conn:
            conn.close()

def preset_selected(preset_number, button=None):
    
    try: 
        global active_button

        # Reset the color of the previously active button
        if active_button:
            active_button.config(bg=button_color)  # Default button color = SystemButtonFace

        # Find and highlight the new active button
        if button:  # If called from GUI
            active_button = button
        elif 1 <= preset_number <= len(buttons):  # If called from MIDI
            active_button = buttons[preset_number - 1]
        else:
            print(f"No button found for preset number: {preset_number}")
            return

        active_button.config(bg=button_markupcolor)  # Highlight the active button
        
        if button:
            update_pc_message(f"GUI {preset_number}")
   
        # Update the model name display
        preset_name_from_list = preset_names[int(active_preset_no)-1] # get preset name from list
        raw_name = Presetsend(preset_number)  # Get preset name from tonex
        if raw_name is not None and raw_name !="Unknown": 
                  name = re.sub(r'[^a-zA-Z0-9 ()]', '', raw_name)  # Clean: only letters, numbers, spaces, and ()
        else: 
           name = preset_name_from_list
                   
        model_name.set(name)

        # Look up the skin using the cleaned name
        skin_result = get_skin_by_preset_name(db_path, name)
        if not skin_result:
            skin_result = "default"  # Use a default skin if none is found

        # Update the image
        update_image(skin_result)
    
    except Exception as e:
            print("Error Present selection")
            #print(f"Error: {e}")

# Frame for the buttons
button_frame = tk.Frame(root, bg=background_color)  
button_frame.pack(side=tk.RIGHT, expand=True, fill=tk.BOTH, padx=20, pady=20)
#button_frame.pack(side=tk.RIGHT, expand=True, fill=tk.BOTH, padx=20, pady=20)

# List to store buttons, indexed by preset number (1-based)
buttons = []

# Create buttons dynamically
def create_buttons():
    try:
        buttons.clear()  # Important that it's not appending more than 20 ;)
        for i in range(20):
            preset_number = i + 1
            name = preset_names[i] if i < len(preset_names) else "Unknown"
            btn = tk.Button(
                button_frame,
                text=f"  {preset_number} - {name}",
                font=(button_font, button_fontsize),
                anchor="w",  # Align text to the left
                bg=button_color,  # Set button background to grey
                fg=button_fontcolor  # Set button text color to white for better contrast
            )
            # Capture the current button in the lambda's default parameter
            btn.config(command=lambda num=preset_number, button=btn: preset_selected(num, button))
            btn.grid(row=i % 10, column=i // 10, sticky="nsew", padx=10, pady=5)
            buttons.append(btn)

        # Make grid scalable
        for i in range(10):
            button_frame.grid_rowconfigure(i, weight=1)
        for j in range(2):
            button_frame.grid_columnconfigure(j, weight=1)
    except Exception as e:
            print("Error create button")
            #print(f"Error: {e}")

# MIDI listener
def handle_midi_messages():
    # Listens for MIDI messages and updates the GUI.
    available_ports = mido.get_input_names()
    if not available_ports:
        print("No MIDI input ports found. Ensure your MIDI device is connected.")
        return
    
    input_name = available_ports[0]
    
    try:
        with mido.open_input(input_name) as midi_input:
            print(f"Listening for MIDI Program Change on {input_name}, channel {midi_channel}")
            while True:
                for msg in midi_input.iter_pending():
                    if msg.type == 'program_change': 
                        if midi_channel == "all" or msg.channel == (midi_channel - 1): # else other midi channel, no action
                            program_number = msg.program + 1
                            update_pc_message(f"PC {program_number}")
                            root.after(0, preset_selected, program_number)  # Call preset_selected safely
                time.sleep(0.1)
    except KeyboardInterrupt:
        print("\nMIDI listener stopped gracefully.")
        
# Initialize preset names and buttons
preset_names = Initlist()
active_preset_no = Activepreset()
if active_preset_no is not None and 1 <= int(Activepreset()) <= 20:
    root.after(100, lambda: preset_selected(int(Activepreset())))
else:
    print(f"Active preset number {active_preset_no} invalid.")

create_buttons()

# Update button labels dynamically if names are populated later
root.after(10, lambda: create_buttons())

# Run the MIDI listener in a separate thread
midi_thread = threading.Thread(target=handle_midi_messages, daemon=True)
midi_thread.start()

# Run the application
root.mainloop()
