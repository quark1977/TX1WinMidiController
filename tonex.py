"""
MIT License

Copyright (c) 2024 quark77

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

# Credits to https://github.com/vit3k/tonex_controller and https://github.com/Builty/TonexOneController for some of the details of below implementation
# This script includes code suggestions generated by ChatGPT, OpenAI (https://openai.com/chatgpt).
# Implements two-way communication with TonexOne over USB, to be called in TX1WinMidiController.py
# Includes functions for CRC, HDLC, Framing, message parsing, preset changing (only slot C), and retrieving of all preset names stored on pedal
# Note: USB communication does NOT work if Tonex App is open, as it blocks the USB port.

import serial
import serial.tools.list_ports
import re

# Define the VID and PID of the device
TONEX_ONE_USB_DEVICE_VID = 0x1963
TONEX_ONE_USB_DEVICE_PID = 0x00d1
BAUD_RATE = 115200

# Configure the serial port (# Find the COM port for the device)
def find_com_port(vid, pid):
    """Find the COM port for a device with the given VID and PID."""
    ports = serial.tools.list_ports.comports()
    for port in ports:
        if (port.vid == vid) and (port.pid == pid):
            return port.device  # Returns the COM port (e.g., 'COM4')
    return None

SERIAL_PORT = find_com_port(TONEX_ONE_USB_DEVICE_VID, TONEX_ONE_USB_DEVICE_PID)
if SERIAL_PORT:
    print(f"Device found on {SERIAL_PORT}")
else:
    print("Device not found.")  

# Calculate CRC with Little Endian CRC 16-bit (reversed polynominal
def calculate_crc(data): #tested
    """Calculate CRC-16 using the reversed polynomial."""
    crc = 0xFFFF
    for byte in data:
        crc ^= byte
        for _ in range(8):
            if crc & 1:
                crc = (crc >> 1) ^ 0x8408  # Reversed polynomial (little endian)
            else:
                crc >>= 1
    crc = ~crc & 0xFFFF  # Final inversion and keep CRC 16-bit
    return [(crc >> 8) & 0xFF, crc & 0xFF]  # Return as [MSB, LSB] (little endian)
    #return crc #as 16-bit


def add_byte_with_stuffing(output, byte): #tested
    """Add a byte with HDLC byte stuffing if necessary."""
    if byte == 0x7E or byte == 0x7D:  # Escape special bytes
        output.append(0x7D)
        output.append(byte ^ 0x20)
    else:
        output.append(byte)


def add_framing_and_crc(payload): #tested
    """Add HDLC framing and CRC to the payload."""
    output = [0x7E]  # Start flag
    for byte in payload:
        add_byte_with_stuffing(output, byte)

    # Add CRC with byte stuffing
    crc = calculate_crc(payload) #question: does crc it not to take into consider hdlc too? 
    add_byte_with_stuffing(output, crc[1])  # LSB of CRC
    add_byte_with_stuffing(output, crc[0])  # MSB of CRC

    output.append(0x7E)  # End flag
    return output


def add_framing_and_crc_and_header(payload, header): 
    """Add HDLC framing and CRC to the payload."""
    output = [0x7E]  # Start flag
    output = output + header  #add header
    for byte in payload:
        add_byte_with_stuffing(output, byte)
    
    # Add CRC with byte stuffing
    crc = calculate_crc(header+payload) #question: does crc it not to take into consider hdlc too? 
    add_byte_with_stuffing(output, crc[1])  # LSB of CRC
    add_byte_with_stuffing(output, crc[0])  # MSB of CRC

    output.append(0x7E)  # End flag
    return output

# Process input_data to remove framing and escape sequences, validate CRC, and return the status and processed data.
def remove_framing(input_data): 
    
    # Check input length and framing
    if len(input_data) < 4 or input_data[0] != 0x7E or input_data[-1] != 0x7E:
        print("Invalid Frame (1)")
        return "STATUS_INVALID_FRAME", []

    output = []
    i = 1  # Start processing after the initial frame marker

    # Process the input data, excluding the final frame marker
    while i < len(input_data) - 1:
        if input_data[i] == 0x7D:  # Escape character detected
            if i + 1 >= len(input_data) - 1:
                print("Invalid Escape sequence")
                return "STATUS_INVALID_ESCAPE_SEQUENCE", []

            # Unescape the next byte
            output.append(input_data[i + 1] ^ 0x20)
            i += 2  # Skip the next byte
        elif input_data[i] == 0x7E:  # Premature frame marker
            break
        else:
            output.append(input_data[i])
            i += 1

    # Check minimum output length
    if len(output) < 2:
        print("Invalid Frame (2)")
        return "STATUS_INVALID_FRAME", []
    
    received_crc = [output[-1], output[-2]] # Return as [MSB, LSB] (little endian)
    output = output[:-2]  # Remove the CRC bytes

    # Calculate and verify CRC
    calculated_crc = calculate_crc(output)
    if received_crc != calculated_crc:
        print(f"CRC mismatch: {received_crc}, {calculated_crc}")
        return "STATUS_CRC_MISMATCH", []

    # Return the processed output
    return output
    
# Parse_Value: go through header data, follow through with index
def parse_value(data, index): 
    if data[index] in (0x81, 0x82):  # Extended encoding
        value = (data[index + 2] << 8) | data[index + 1]
        index += 3
    elif data[index] == 0x80:  # Short encoding
        value = data[index + 1]
        index += 2
    else:  # Single byte
        value = data[index]
        index += 1
    return value, index

# Parse: extract raw payload (without header) from unframed_response
def parse_response(response):  
    if len(response) < 5:
        raise ValueError("Response too short")

    # Ensure the message has the correct start bytes
    if response[0] != 0xB9 or response[1] != 0x03:
        raise ValueError("Invalid header")

    # Parse header values (in 3 steps, keep following through with index)
    index = 2
    message_type, index = parse_value(response, index)
    header_size, index = parse_value(response, index)
    unknown_field, index = parse_value(response, index)

    # Validate payload size
    payload_size = len(response) - index
    if payload_size != header_size:
        raise ValueError("Payload size does not match header size")

    # Extract raw payload
    raw_payload = response[index:]    
    return {
        "type": message_type,
        "header_size": header_size,
        "unknown": unknown_field,
        "raw_payload": raw_payload,
    }


# Modify the core string of the raw_payload to set Slot C's preset to the specified value. 
def change_slot_c_preset(payload, new_preset):  # new_preset (int): The new preset value (1-20).
    # Validate new preset value
    
    if not (1 <= new_preset <= 20):
        raise ValueError("Preset must be between 1 and 20.")

    # Convert payload to a mutable list
    payload = list(payload)

    # Locate Slot C preset position
    preset_position = len(payload) - 14

    # Modify Slot C preset
    payload[preset_position] = new_preset-1 #preset 1 in tonex app is set to 0 on tonex pedal. 

    # Create header:                              len LSB               len MSB
    header = [0xb9, 0x03, 0x81, 0x06, 0x03, 0x82, len(payload) & 0xFF, (len(payload) >> 8) & 0xFF, 0x80, 0x0b, 0x03]  
    
    # Reapply framing and CRC: ([0x7E] + header + payload + new_crc + [0x7E]). CRC is calculated on (header + payload)!
    message=bytes(add_framing_and_crc_and_header(payload, header)) 

    return message

# payloads for hello and request, tested, work as wekl. 
hello = [0xb9, 0x03, 0x00, 0x82, 0x04, 0x00, 0x80, 0x0b, 0x01, 0xb9, 0x02, 0x02, 0x0b]
framed_hello = add_framing_and_crc(hello) # frame payload adds crc, hdlc, frame 0x7E to the core message. 

requeststate = [0xb9, 0x03, 0x00, 0x82, 0x06, 0x00, 0x80, 0x0b, 0x03, 0xb9, 0x02, 0x81, 0x06, 0x03, 0x0b]
framed_request = add_framing_and_crc(requeststate) # frame payload adds crc, hdlc, frame 0x7E to the core message. 

# Create and send the payload to trigger Preset change and return the name of preset name
def Presetsend(new_preset):
    try:
        with serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=0.10) as ser:
            
            # Send Hello
            ser.write(bytes(framed_hello))
            response = ser.read(3072)
            
            # Trigger response to retrieve raw data
            ser.write(bytes(framed_request))
            response = ser.read(3072)
            unframed_response = remove_framing(response) # take away frame and crc, also check crc of received string.
            raw_payload = parse_response(unframed_response)["raw_payload"] 
                    
            #change the slot C to preset 2
            Change_message = change_slot_c_preset(raw_payload, new_preset) # e.g. 8 here = 9 in the list of tonex app. 
            ser.write(bytes(Change_message))
            response = ser.read(6000)
            # Extract preset name from response
            start_marker = b'\xbc!' # for preset name
            start_index = response.find(start_marker) + len(start_marker)
            if start_index>1: 
                name = response[start_index:].split(b'\x00')[0].decode('utf-8') # Extract the preset name, stopping at the first null byte (\x00)
            else:
                name= "Unknown" 
            # print("Preset name:", name)
        return name
            
    except Exception as e:
        print("Error Present send - Close Tonex App and check USB connection")
        #print(f"Error: {e}")
        
# Send state request and extract active prset number
def Activepreset():
    try:
        with serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=0.10) as ser:
            
            # Send Hello
            ser.write(bytes(framed_hello))
            response = ser.read(3072)
            
            # Trigger response to retrieve raw data
            ser.write(bytes(framed_request))
            response = ser.read(3072)
            unframed_response = remove_framing(response) # take away frame and crc, also check crc of received string.
            presetno = unframed_response[len(unframed_response)-14]+1 #bring back active preset number (14 from the right)
            print(f"Activepreset - preset no {presetno}")
        return presetno
            
    except Exception as e:
        print("Error Active Present reception")
        #print(f"Error: {e}")
        
        
def Initlist():
    names_list = []  # Initialize an empty list to store names
    try:
        with serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=0.05) as ser:
            request_string = "b903810003820600800b03b9040b010100"
            for i in range(0, 20):
                # Convert the integer to a two-digit hex string
                last_byte = f"{i:02x}"
                # Modify the second-to-last byte
                modified_string = request_string[:-4] + last_byte + request_string[-2:]
                # Add framing and CRC
                framed_string = add_framing_and_crc(bytes.fromhex(modified_string))
                # Send the framed string
                ser.write(bytes(framed_string))  # fromhex() converts hex strings directly to bytes
                response = ser.read(6000)
                # Extract preset name from response
                start_marker = b'\xbc!' # for preset name
                start_index = response.find(start_marker) + len(start_marker)
                if start_index>1:
                    name = response[start_index:].split(b'\x00')[0].decode('utf-8') # Extract the preset name, stopping at the first null byte (\x00)
                    names_list.append(name)  # Add the preset name to the list
                else:
                    names_list.append("Unknown")  # Add the preset name to the list
            # print("Collected Names:", names_list)  # names list
        return names_list
    except Exception as e:
        print("Error Initialization - Close Tonex App and check USB connection")
        #print(f"Error: {e}")
    
    return names_list  # Return the list of names

        
if __name__ == "__main__":
    #Presetsend(14) # only for debugging tonex script
    #Initlist() # only for debugging tonex script
    
    Activepreset()